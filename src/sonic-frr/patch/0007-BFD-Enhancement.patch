diff --git a/bfdd/bfd.c b/bfdd/bfd.c
index 875b41e7f..b10354c69 100644
--- a/bfdd/bfd.c
+++ b/bfdd/bfd.c
@@ -49,6 +49,8 @@ static void bs_admin_down_handler(struct bfd_session *bs, int nstate);
 static void bs_down_handler(struct bfd_session *bs, int nstate);
 static void bs_init_handler(struct bfd_session *bs, int nstate);
 static void bs_up_handler(struct bfd_session *bs, int nstate);
+static void bs_neighbour_admin_down_handler(struct bfd_session *bfd,
+					    uint8_t diag);
 
 /* Zeroed array with the size of an IPv6 address. */
 struct in6_addr zero_addr;
@@ -238,6 +240,18 @@ static uint32_t ptm_bfd_gen_ID(void)
 	return session_id;
 }
 
+void bfd_clear_stored_pkt(struct bfd_session *bs)
+{
+	if (bs->bfd_tx_pkt_stored == false)
+		return;
+
+	memset(&(bs->bfd_tx_pkt), 0, sizeof(bs->bfd_tx_pkt));
+	bs->bfd_tx_pkt_stored = false;
+
+	log_debug_pkt("clear-packet: session-id: %d",
+		       bs->discrs.my_discr);
+}
+
 void ptm_bfd_start_xmt_timer(struct bfd_session *bfd, bool is_echo)
 {
 	uint64_t jitter, xmt_TO;
@@ -273,6 +287,9 @@ static void ptm_bfd_echo_xmt_TO(struct bfd_session *bfd)
 
 void ptm_bfd_xmt_TO(struct bfd_session *bfd, int fbit)
 {
+	if (fbit)
+		bfd_clear_stored_pkt(bfd);
+
 	/* Send the scheduled control packet */
 	ptm_bfd_snd(bfd, fbit);
 
@@ -311,7 +328,7 @@ void ptm_bfd_sess_up(struct bfd_session *bfd)
 	/* Start sending control packets with poll bit immediately. */
 	ptm_bfd_snd(bfd, 0);
 
-	control_notify(bfd);
+	control_notify(bfd, bfd->ses_state);
 
 	if (old_state != bfd->ses_state) {
 		bfd->stats.session_up++;
@@ -332,6 +349,8 @@ void ptm_bfd_sess_dn(struct bfd_session *bfd, uint8_t diag)
 	bfd->demand_mode = 0;
 	monotime(&bfd->downtime);
 
+	bfd_clear_stored_pkt(bfd);
+	
 	/*
 	 * Only attempt to send if we have a valid socket:
 	 * this function might be called by session disablers and in
@@ -346,7 +365,7 @@ void ptm_bfd_sess_dn(struct bfd_session *bfd, uint8_t diag)
 
 	/* only signal clients when going from up->down state */
 	if (old_state == PTM_BFD_UP)
-		control_notify(bfd);
+		control_notify(bfd, PTM_BFD_DOWN);
 
 	/* Stop echo packet transmission if they are active */
 	if (BFD_CHECK_FLAG(bfd->flags, BFD_SESS_FLAG_ECHO_ACTIVE))
@@ -504,6 +523,8 @@ struct bfd_session *bfd_session_new(void)
 	monotime(&bs->uptime);
 	bs->downtime = bs->uptime;
 
+	bs->bfd_tx_pkt_stored = false;
+
 	return bs;
 }
 
@@ -592,7 +613,7 @@ skip_echo:
 
 		/* Change and notify state change. */
 		bs->ses_state = PTM_BFD_ADM_DOWN;
-		control_notify(bs);
+		control_notify(bs, bs->ses_state);
 
 		/* Don't try to send packets with a disabled session. */
 		if (bs->sock != -1)
@@ -606,7 +627,7 @@ skip_echo:
 
 		/* Change and notify state change. */
 		bs->ses_state = PTM_BFD_DOWN;
-		control_notify(bs);
+		control_notify(bs, bs->ses_state);
 
 		/* Enable all timers. */
 		bfd_recvtimer_update(bs);
@@ -800,6 +821,8 @@ void bfd_set_polling(struct bfd_session *bs)
 	 * RFC 5880, Section 6.8.3.
 	 */
 	bs->polling = 1;
+
+	bfd_clear_stored_pkt(bs);
 }
 
 /*
@@ -878,10 +901,46 @@ static void bs_init_handler(struct bfd_session *bs, int nstate)
 	}
 }
 
+static void bs_neighbour_admin_down_handler(struct bfd_session *bfd,
+					    uint8_t diag)
+{
+	int old_state = bfd->ses_state;
+
+	bfd->local_diag = diag;
+	bfd->discrs.remote_discr = 0;
+	bfd->ses_state = PTM_BFD_DOWN;
+	bfd->polling = 0;
+	bfd->demand_mode = 0;
+	monotime(&bfd->downtime);
+
+	/* Slow down the control packets, the connection is down. */
+	bs_set_slow_timers(bfd);
+
+	/* only signal clients when going from up->down state */
+	if (old_state == PTM_BFD_UP)
+		control_notify(bfd, PTM_BFD_ADM_DOWN);
+
+	/* Stop echo packet transmission if they are active */
+	if (BFD_CHECK_FLAG(bfd->flags, BFD_SESS_FLAG_ECHO_ACTIVE))
+		ptm_bfd_echo_stop(bfd);
+
+	if (old_state != bfd->ses_state) {
+		bfd->stats.session_down++;
+
+		log_info("state-change: [%s] %s -> %s reason:%s",
+			bs_to_string(bfd), state_list[old_state].str,
+			state_list[bfd->ses_state].str,
+			get_diag_str(bfd->local_diag));
+	}
+}
+
 static void bs_up_handler(struct bfd_session *bs, int nstate)
 {
 	switch (nstate) {
 	case PTM_BFD_ADM_DOWN:
+		bs_neighbour_admin_down_handler(bs, BD_ADMIN_DOWN);
+		break;
+
 	case PTM_BFD_DOWN:
 		/* Peer lost or asked to shutdown connection. */
 		ptm_bfd_sess_dn(bs, BD_NEIGHBOR_DOWN);
@@ -1763,3 +1822,8 @@ struct bfd_vrf_global *bfd_vrf_look_by_session(struct bfd_session *bfd)
 		return NULL;
 	return bfd->vrf->info;
 }
+
+unsigned long bfd_get_session_count(void)
+{
+	return bfd_key_hash->count;
+}
diff --git a/bfdd/bfd.h b/bfdd/bfd.h
index 3b81d7e12..d2f129864 100644
--- a/bfdd/bfd.h
+++ b/bfdd/bfd.h
@@ -242,6 +242,11 @@ struct bfd_session {
 	/* BFD session flags */
 	enum bfd_session_flags flags;
 
+	/* Flag to indicate if Tx packet is filled in below structure */
+	bool bfd_tx_pkt_stored;
+	/* Stored packet for Tx in Async mode */
+	struct bfd_pkt bfd_tx_pkt;
+
 	struct bfd_session_stats stats;
 
 	struct timeval uptime;   /* last up time */
@@ -365,10 +370,11 @@ TAILQ_HEAD(bcslist, bfd_control_socket);
 
 int control_init(const char *path);
 void control_shutdown(void);
-int control_notify(struct bfd_session *bs);
+int control_notify(struct bfd_session *bs, uint8_t notify_state);
 int control_notify_config(const char *op, struct bfd_session *bs);
 int control_accept(struct thread *t);
 
+void bfd_clear_stored_pkt(struct bfd_session *bs);
 
 /*
  * bfdd.c
@@ -445,6 +451,7 @@ void log_init(int foreground, enum blog_level level,
 	      struct frr_daemon_info *fdi);
 void log_info(const char *fmt, ...);
 void log_debug(const char *fmt, ...);
+void log_debug_pkt(const char *fmt, ...);
 void log_warning(const char *fmt, ...);
 void log_error(const char *fmt, ...);
 void log_fatal(const char *fmt, ...);
@@ -567,6 +574,8 @@ typedef void (*hash_iter_func)(struct hash_bucket *hb, void *arg);
 void bfd_id_iterate(hash_iter_func hif, void *arg);
 void bfd_key_iterate(hash_iter_func hif, void *arg);
 
+unsigned long bfd_get_session_count(void);
+
 /* Export callback functions for `event.c`. */
 extern struct thread_master *master;
 
@@ -627,7 +636,7 @@ void bfdd_zclient_register(vrf_id_t vrf_id);
 void bfdd_sessions_enable_vrf(struct vrf *vrf);
 void bfdd_sessions_disable_vrf(struct vrf *vrf);
 
-int ptm_bfd_notify(struct bfd_session *bs);
+int ptm_bfd_notify(struct bfd_session *bs, uint8_t notify_state);
 
 
 /*
@@ -637,4 +646,32 @@ int ptm_bfd_notify(struct bfd_session *bs);
  */
 extern const struct frr_yang_module_info frr_bfdd_info;
 
+/* bfd_debug.c*/
+/* Prototypes. */
+extern void bfd_debug_init(void);
+
+extern bool conf_bfd_debug_pkt;
+
+extern bool term_bfd_debug_pkt;
+
+#define BFD_CONF_DEBUG_PKT_ON() (conf_bfd_debug_pkt = true)
+#define BFD_CONF_DEBUG_PKT_OFF() (conf_bfd_debug_pkt = false)
+
+#define BFD_TERM_DEBUG_PKT_ON() (term_bfd_debug_pkt = true)
+#define BFD_TERM_DEBUG_PKT_OFF() (term_bfd_debug_pkt = false)
+
+#define BFD_DEBUG_PKT_ON()				\
+	do {						\
+		BFD_CONF_DEBUG_PKT_ON();		\
+		BFD_TERM_DEBUG_PKT_ON();		\
+	} while (0)
+#define BFD_DEBUG_PKT_OFF()				\
+	do {						\
+		BFD_CONF_DEBUG_PKT_OFF();		\
+		BFD_TERM_DEBUG_PKT_OFF();		\
+	} while (0)
+
+#define BFD_DEBUG_PKT() (true == term_bfd_debug_pkt)
+#define CONF_BFD_DEBUG_PKT() (true == conf_bfd_debug_pkt)
+
 #endif /* _BFD_H_ */
diff --git a/bfdd/bfd_debug.c b/bfdd/bfd_debug.c
new file mode 100644
index 000000000..8ef930bfc
--- /dev/null
+++ b/bfdd/bfd_debug.c
@@ -0,0 +1,105 @@
+/*
+ * bfd_debug.c: Implements the BFD debug functions.
+ * Copyright (C) 2019 Broadcom. The term "Broadcom" refers to Broadcom Inc.
+ * and/or its subsidiaries.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 (GPLv2) as
+ * published by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License GPLv2
+ * License along with this program; see the file COPYING; if not, write to
+ * the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ * MA 02110-1301 USA
+ */
+
+#include "command.h"
+#include "bfd.h"
+
+bool conf_bfd_debug_pkt;
+bool term_bfd_debug_pkt;
+
+DEFUN (debug_bfd,
+       debug_bfd_cmd,
+       "debug bfd packet",
+       DEBUG_STR
+       BFD_STR
+       "BFD packets")
+{
+	if (vty->node == CONFIG_NODE)
+		BFD_DEBUG_PKT_ON();
+	else {
+		BFD_TERM_DEBUG_PKT_ON();
+		vty_out(vty, "BFD packet debugging is on\n");
+	}
+	return CMD_SUCCESS;
+}
+
+DEFUN (no_debug_bfd,
+       no_debug_bfd_cmd,
+       "no debug bfd packet",
+       NO_STR
+       DEBUG_STR
+       BFD_STR
+       "BFD packets")
+{
+	if (vty->node == CONFIG_NODE)
+		BFD_DEBUG_PKT_OFF();
+	else {
+		BFD_TERM_DEBUG_PKT_OFF();
+		vty_out(vty, "BFD packet debugging is off\n");
+	}
+	return CMD_SUCCESS;
+}
+
+DEFUN_NOSH (show_debugging_bfd,
+	    show_debugging_bfd_cmd,
+	    "show debugging [bfd]",
+	    SHOW_STR
+	    DEBUG_STR
+	    BFD_STR)
+{
+	vty_out(vty, "BFD debugging status:\n");
+
+	if (BFD_DEBUG_PKT())
+		vty_out(vty, "  BFD debugging is on\n");
+
+	vty_out(vty, "\n");
+	return CMD_SUCCESS;
+}
+
+static int bfd_config_write_debug(struct vty *vty)
+{
+	int write = 0;
+
+	if (CONF_BFD_DEBUG_PKT()) {
+		vty_out(vty, "debug bfd packets\n");
+		write++;
+	}
+
+	return write;
+}
+
+static struct cmd_node debug_node = {DEBUG_NODE, "", 1};
+
+void bfd_debug_init(void)
+{
+	install_node(&debug_node, bfd_config_write_debug);
+
+	install_element(ENABLE_NODE, &show_debugging_bfd_cmd);
+
+	install_element(ENABLE_NODE, &debug_bfd_cmd);
+	install_element(CONFIG_NODE, &debug_bfd_cmd);
+
+	install_element(ENABLE_NODE, &no_debug_bfd_cmd);
+	install_element(CONFIG_NODE, &no_debug_bfd_cmd);
+
+}
+
+
diff --git a/bfdd/bfd_packet.c b/bfdd/bfd_packet.c
index 2de3bb470..41f5b69b4 100644
--- a/bfdd/bfd_packet.c
+++ b/bfdd/bfd_packet.c
@@ -215,6 +215,14 @@ static int ptm_bfd_process_echo_pkt(struct bfd_vrf_global *bvrf, int s)
 void ptm_bfd_snd(struct bfd_session *bfd, int fbit)
 {
 	struct bfd_pkt cp;
+	struct bfd_pkt *pst_bfd_pkt = NULL;
+
+	if ((bfd->bfd_tx_pkt_stored) &&
+	    (bfd->ses_state == PTM_BFD_UP) && (!bfd->polling) && (!fbit)) {
+		pst_bfd_pkt = &(bfd->bfd_tx_pkt);
+
+		goto send_packet;
+	}
 
 	/* Set fields according to section 6.5.7 */
 	cp.diag = bfd->local_diag;
@@ -257,9 +265,22 @@ void ptm_bfd_snd(struct bfd_session *bfd, int fbit)
 		cp.timers.required_min_rx =
 			htonl(bfd->cur_timers.required_min_rx);
 	}
+
 	cp.timers.required_min_echo = htonl(bfd->timers.required_min_echo);
 
-	if (_ptm_bfd_send(bfd, NULL, &cp, BFD_PKT_LEN) != 0)
+	pst_bfd_pkt = &cp;
+
+	if ((BFD_GETSTATE(cp.flags) == PTM_BFD_UP) &&
+	     (!bfd->polling) && !(fbit)) {
+		memcpy(&(bfd->bfd_tx_pkt), pst_bfd_pkt, sizeof(bfd->bfd_tx_pkt));
+		bfd->bfd_tx_pkt_stored = true;
+
+		log_debug_pkt("storing-packet: session-id: %d",
+			       bfd->discrs.my_discr);
+	}
+
+send_packet:
+	if (_ptm_bfd_send(bfd, NULL, pst_bfd_pkt, BFD_PKT_LEN) != 0)
 		return;
 
 	bfd->stats.tx_ctrl_pkt++;
diff --git a/bfdd/bfdd_cli.c b/bfdd/bfdd_cli.c
index acb1801cc..e02ff5ed0 100644
--- a/bfdd/bfdd_cli.c
+++ b/bfdd/bfdd_cli.c
@@ -409,4 +409,6 @@ bfdd_cli_init(void)
 	install_element(BFD_PEER_NODE, &bfd_peer_tx_cmd);
 	install_element(BFD_PEER_NODE, &bfd_peer_echo_cmd);
 	install_element(BFD_PEER_NODE, &bfd_peer_echo_interval_cmd);
+
+	bfd_debug_init();
 }
diff --git a/bfdd/bfdd_northbound.c b/bfdd/bfdd_northbound.c
index 6bcc5d66b..e6508f346 100644
--- a/bfdd/bfdd_northbound.c
+++ b/bfdd/bfdd_northbound.c
@@ -434,7 +434,7 @@ static int bfdd_bfd_sessions_single_hop_administrative_down_modify(
 
 		/* Change and notify state change. */
 		bs->ses_state = PTM_BFD_DOWN;
-		control_notify(bs);
+		control_notify(bs, PTM_BFD_DOWN);
 
 		/* Enable all timers. */
 		bfd_recvtimer_update(bs);
@@ -457,7 +457,7 @@ static int bfdd_bfd_sessions_single_hop_administrative_down_modify(
 
 		/* Change and notify state change. */
 		bs->ses_state = PTM_BFD_ADM_DOWN;
-		control_notify(bs);
+		control_notify(bs, PTM_BFD_ADM_DOWN);
 
 		ptm_bfd_snd(bs, 0);
 	}
diff --git a/bfdd/bfdd_vty.c b/bfdd/bfdd_vty.c
index 0898ffd95..87e5e82a3 100644
--- a/bfdd/bfdd_vty.c
+++ b/bfdd/bfdd_vty.c
@@ -142,8 +142,12 @@ static void _display_peer(struct vty *vty, struct bfd_session *bs)
 
 	vty_out(vty, "\t\tDiagnostics: %s\n", diag2str(bs->local_diag));
 	vty_out(vty, "\t\tRemote diagnostics: %s\n", diag2str(bs->remote_diag));
+	vty_out(vty, "\t\tPeer Type: %s\n",
+		BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_CONFIG) ? "configured" : "dynamic");
 
 	vty_out(vty, "\t\tLocal timers:\n");
+	vty_out(vty, "\t\t\tDetect-multiplier: %" PRIu32 "\n",
+		bs->detect_mult);
 	vty_out(vty, "\t\t\tReceive interval: %" PRIu32 "ms\n",
 		bs->timers.required_min_rx / 1000);
 	vty_out(vty, "\t\t\tTransmission interval: %" PRIu32 "ms\n",
@@ -152,6 +156,8 @@ static void _display_peer(struct vty *vty, struct bfd_session *bs)
 		bs->timers.required_min_echo / 1000);
 
 	vty_out(vty, "\t\tRemote timers:\n");
+	vty_out(vty, "\t\t\tDetect-multiplier: %" PRIu32 "\n",
+		bs->remote_detect_mult);
 	vty_out(vty, "\t\t\tReceive interval: %" PRIu32 "ms\n",
 		bs->remote_timers.required_min_rx / 1000);
 	vty_out(vty, "\t\t\tTransmission interval: %" PRIu32 "ms\n",
@@ -235,12 +241,16 @@ static struct json_object *__display_peer_json(struct bfd_session *bs)
 	else
 		json_object_int_add(jo, "echo-interval", 0);
 
+	json_object_int_add(jo, "detect-multiplier", bs->detect_mult);
+
 	json_object_int_add(jo, "remote-receive-interval",
 			    bs->remote_timers.required_min_rx / 1000);
 	json_object_int_add(jo, "remote-transmit-interval",
 			    bs->remote_timers.desired_min_tx / 1000);
 	json_object_int_add(jo, "remote-echo-interval",
 			    bs->remote_timers.required_min_echo / 1000);
+	json_object_int_add(jo, "remote-detect-multiplier",
+			    bs->remote_detect_mult);
 
 	return jo;
 }
@@ -305,9 +315,8 @@ static void _display_peer_json_iter(struct hash_bucket *hb, void *arg)
 static void _display_all_peers(struct vty *vty, char *vrfname, bool use_json)
 {
 	struct json_object *jo;
-	struct bfd_vrf_tuple bvt;
+	struct bfd_vrf_tuple bvt = {0};
 
-	memset(&bvt, 0, sizeof(bvt));
 	bvt.vrfname = vrfname;
 
 	if (!use_json) {
@@ -413,12 +422,12 @@ static void _display_peer_counter_json_iter(struct hash_bucket *hb, void *arg)
 	json_object_array_add(jo, jon);
 }
 
-static void _display_peers_counter(struct vty *vty, char *vrfname, bool use_json)
+static void _display_peers_counter(struct vty *vty, char *vrfname,
+				   bool use_json)
 {
 	struct json_object *jo;
-	struct bfd_vrf_tuple bvt;
+	struct bfd_vrf_tuple bvt = {0};
 
-	memset(&bvt, 0, sizeof(struct bfd_vrf_tuple));
 	bvt.vrfname = vrfname;
 	if (!use_json) {
 		bvt.vty = vty;
@@ -435,6 +444,95 @@ static void _display_peers_counter(struct vty *vty, char *vrfname, bool use_json
 	json_object_free(jo);
 }
 
+static void _clear_peer_counter(struct bfd_session *bs)
+{
+	/* Clear only pkt stats, intention is not to loose system
+	 * events counters
+	 */
+	bs->stats.rx_ctrl_pkt = 0;
+	bs->stats.tx_ctrl_pkt = 0;
+	bs->stats.rx_echo_pkt = 0;
+	bs->stats.tx_echo_pkt = 0;
+}
+
+static void _display_peer_brief(struct vty *vty, struct bfd_session *bs)
+{
+	char addr_buf[INET6_ADDRSTRLEN];
+
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH)) {
+		vty_out(vty, "%-10u", bs->discrs.my_discr);
+		inet_ntop(bs->key.family, &bs->key.local, addr_buf,
+			  sizeof(addr_buf));
+		vty_out(vty, " %-40s", addr_buf);
+		inet_ntop(bs->key.family, &bs->key.peer, addr_buf,
+			  sizeof(addr_buf));
+		vty_out(vty, " %-40s", addr_buf);
+		vty_out(vty, "%-15s\n", state_list[bs->ses_state].str);
+	} else {
+		vty_out(vty, "%-10u", bs->discrs.my_discr);
+		vty_out(vty, " %-40s", satostr(&bs->local_address));
+		inet_ntop(bs->key.family, &bs->key.peer, addr_buf,
+			  sizeof(addr_buf));
+		vty_out(vty, " %-40s", addr_buf);
+
+		vty_out(vty, "%-15s\n", state_list[bs->ses_state].str);
+	}
+}
+
+static void _display_peer_brief_iter(struct hash_backet *hb, void *arg)
+{
+	struct bfd_vrf_tuple *bvt = arg;
+	struct vty *vty;
+	struct bfd_session *bs = hb->data;
+
+	if (!bvt)
+		return;
+	vty = bvt->vty;
+
+	if (bvt->vrfname) {
+		if (!bs->key.vrfname[0] ||
+			!strmatch(bs->key.vrfname, bvt->vrfname))
+			return;
+	}
+
+	_display_peer_brief(vty, bs);
+}
+
+static void _display_peers_brief(struct vty *vty, char *vrfname,
+				 bool use_json)
+{
+	struct json_object *jo;
+	struct bfd_vrf_tuple bvt = {0};
+
+	bvt.vrfname = vrfname;
+
+	if (use_json == false) {
+		bvt.vty = vty;
+
+		vty_out(vty, "Session count: %lu\n", bfd_get_session_count());
+		vty_out(vty, "%-10s", "SessionId");
+		vty_out(vty, " %-40s", "LocalAddress");
+		vty_out(vty, " %-40s", "PeerAddress");
+		vty_out(vty, "%-15s\n", "Status");
+
+		vty_out(vty, "%-10s", "=========");
+		vty_out(vty, " %-40s", "============");
+		vty_out(vty, " %-40s", "===========");
+		vty_out(vty, "%-15s\n", "======");
+
+		bfd_id_iterate(_display_peer_brief_iter, &bvt);
+		return;
+	}
+
+	jo = json_object_new_array();
+	bvt.jo = jo;
+
+	bfd_id_iterate(_display_peer_json_iter, &bvt);
+
+	vty_out(vty, "%s\n", json_object_to_json_string_ext(jo, 0));
+	json_object_free(jo);
+}
+
 static struct bfd_session *
 _find_peer_or_error(struct vty *vty, int argc, struct cmd_token **argv,
 		    const char *label, const char *peer_str,
@@ -596,6 +694,56 @@ DEFPY(bfd_show_peers_counters, bfd_show_peers_counters_cmd,
 	return CMD_SUCCESS;
 }
 
+DEFPY(bfd_clear_peer_counters, bfd_clear_peer_counters_cmd,
+      "clear bfd [vrf <NAME$vrfname>] peer <WORD$label|<A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname}]> counters",
+      SHOW_STR
+      "Bidirection Forwarding Detection\n"
+      VRF_CMD_HELP_STR
+      "BFD peers status\n"
+      "Peer label\n"
+      PEER_IPV4_STR
+      PEER_IPV6_STR
+      MHOP_STR
+      LOCAL_STR
+      LOCAL_IPV4_STR
+      LOCAL_IPV6_STR
+      INTERFACE_STR
+      LOCAL_INTF_STR
+      "clear BFD peer counters information\n")
+{
+	struct bfd_session *bs;
+
+	/* Look up the BFD peer. */
+	bs = _find_peer_or_error(vty, argc, argv, label, peer_str, local_str,
+				 ifname, vrfname);
+
+	if (bs == NULL)
+		return CMD_WARNING_CONFIG_FAILED;
+
+	_clear_peer_counter(bs);
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(bfd_show_peers_brief, bfd_show_peers_brief_cmd,
+      "show bfd [vrf <NAME$vrfname>] peers brief [json]",
+      SHOW_STR
+      "Bidirection Forwarding Detection\n"
+      VRF_CMD_HELP_STR
+      "BFD peers status\n"
+      "Show BFD peer information in tabular form\n"
+      JSON_STR)
+{
+	char *vrf_name = NULL;
+	int idx_vrf = 0;
+
+	if (argv_find(argv, argc, "vrf", &idx_vrf))
+		vrf_name = argv[idx_vrf + 1]->arg;
+
+	_display_peers_brief(vty, vrf_name, use_json(argc, argv));
+
+	return CMD_SUCCESS;
+}
 
 /*
  * Function definitions.
@@ -690,17 +838,6 @@ static int bfd_configure_peer(struct bfd_peer_cfg *bpc, bool mhop,
 	return 0;
 }
 
-DEFUN_NOSH(show_debugging_bfd,
-	   show_debugging_bfd_cmd,
-	   "show debugging [bfd]",
-	   SHOW_STR
-	   DEBUG_STR
-	   "BFD daemon\n")
-{
-	vty_out(vty, "BFD debugging status:\n");
-
-	return CMD_SUCCESS;
-}
 
 struct cmd_node bfd_node = {
 	BFD_NODE,
@@ -732,9 +869,10 @@ void bfdd_vty_init(void)
 {
 	install_element(ENABLE_NODE, &bfd_show_peers_counters_cmd);
 	install_element(ENABLE_NODE, &bfd_show_peer_counters_cmd);
+	install_element(ENABLE_NODE, &bfd_clear_peer_counters_cmd);
 	install_element(ENABLE_NODE, &bfd_show_peers_cmd);
 	install_element(ENABLE_NODE, &bfd_show_peer_cmd);
-	install_element(ENABLE_NODE, &show_debugging_bfd_cmd);
+	install_element(ENABLE_NODE, &bfd_show_peers_brief_cmd);
 
 	/* Install BFD node and commands. */
 	install_node(&bfd_node, bfdd_write_config);
diff --git a/bfdd/control.c b/bfdd/control.c
index c308d647d..5c5421c04 100644
--- a/bfdd/control.c
+++ b/bfdd/control.c
@@ -774,13 +774,13 @@ static void _control_notify(struct bfd_control_socket *bcs,
 	control_queue_enqueue(bcs, bcm);
 }
 
-int control_notify(struct bfd_session *bs)
+int control_notify(struct bfd_session *bs, uint8_t notify_state)
 {
 	struct bfd_control_socket *bcs;
 	struct bfd_notify_peer *bnp;
 
 	/* Notify zebra listeners as well. */
-	ptm_bfd_notify(bs);
+	ptm_bfd_notify(bs, notify_state);
 
 	/*
 	 * PERFORMANCE: reuse the bfd_control_msg allocated data for
diff --git a/bfdd/log.c b/bfdd/log.c
index d81d7cd9b..5397a8e0c 100644
--- a/bfdd/log.c
+++ b/bfdd/log.c
@@ -95,6 +95,18 @@ void log_debug(const char *fmt, ...)
 	va_end(vl);
 }
 
+void log_debug_pkt(const char *fmt, ...)
+{
+	va_list vl;
+
+	if (!BFD_DEBUG_PKT())
+		return;
+
+	va_start(vl, fmt);
+	log_msg(BLOG_DEBUG, fmt, vl);
+	va_end(vl);
+}
+
 void log_error(const char *fmt, ...)
 {
 	va_list vl;
diff --git a/bfdd/ptm_adapter.c b/bfdd/ptm_adapter.c
index 707d3e581..516306758 100644
--- a/bfdd/ptm_adapter.c
+++ b/bfdd/ptm_adapter.c
@@ -153,7 +153,7 @@ static int _ptm_msg_address(struct stream *msg, int family, const void *addr)
 	return 0;
 }
 
-int ptm_bfd_notify(struct bfd_session *bs)
+int ptm_bfd_notify(struct bfd_session *bs, uint8_t notify_state)
 {
 	struct stream *msg;
 
@@ -204,12 +204,15 @@ int ptm_bfd_notify(struct bfd_session *bs)
 	_ptm_msg_address(msg, bs->key.family, &bs->key.peer);
 
 	/* BFD status */
-	switch (bs->ses_state) {
+	switch (notify_state) {
 	case PTM_BFD_UP:
 		stream_putl(msg, BFD_STATUS_UP);
 		break;
 
 	case PTM_BFD_ADM_DOWN:
+		stream_putl(msg, BFD_STATUS_ADMIN_DOWN);
+		break;
+
 	case PTM_BFD_DOWN:
 	case PTM_BFD_INIT:
 		stream_putl(msg, BFD_STATUS_DOWN);
@@ -429,7 +432,7 @@ static void bfdd_dest_register(struct stream *msg, vrf_id_t vrf_id)
 		return;
 	}
 
-	ptm_bfd_notify(bs);
+	ptm_bfd_notify(bs, bs->ses_state);
 }
 
 static void bfdd_dest_deregister(struct stream *msg, vrf_id_t vrf_id)
@@ -458,6 +461,12 @@ static void bfdd_dest_deregister(struct stream *msg, vrf_id_t vrf_id)
 	if (bs->refcount ||
 	    BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_CONFIG))
 		return;
+
+	bs->ses_state = PTM_BFD_ADM_DOWN;
+	ptm_bfd_snd(bs, 0);
+
+	bfd_clear_stored_pkt(bs);
+
 	ptm_bfd_sess_del(&bpc);
 }
 
diff --git a/bfdd/subdir.am b/bfdd/subdir.am
index 5e3c3d476..1be6673d3 100644
--- a/bfdd/subdir.am
+++ b/bfdd/subdir.am
@@ -8,6 +8,7 @@ sbin_PROGRAMS += bfdd/bfdd
 dist_examples_DATA += bfdd/bfdd.conf.sample
 vtysh_scan += $(top_srcdir)/bfdd/bfdd_vty.c
 vtysh_scan += $(top_srcdir)/bfdd/bfdd_cli.c
+vtysh_scan += $(top_srcdir)/bfdd/bfd_debug.c
 man8 += $(MANBUILD)/bfdd.8
 endif
 
@@ -22,6 +23,7 @@ bfdd_libbfd_a_SOURCES = \
 	bfdd/event.c \
 	bfdd/log.c \
 	bfdd/ptm_adapter.c \
+	bfdd/bfd_debug.c \
 	# end
 
 bfdd/bfdd_vty_clippy.c: $(CLIPPY_DEPS)
diff --git a/bgpd/bgp_bfd.c b/bgpd/bgp_bfd.c
index 57fef8e91..0ed6057ea 100644
--- a/bgpd/bgp_bfd.c
+++ b/bgpd/bgp_bfd.c
@@ -282,7 +282,8 @@ static void bgp_bfd_peer_status_update(struct peer *peer, int status,
 		return;
 
 	old_status = bfd_info->status;
-	bfd_info->status = status;
+	BFD_SET_CLIENT_STATUS(bfd_info->status, status);
+
 	bfd_info->last_update = bgp_clock();
 
 	if (status != old_status) {
diff --git a/isisd/isis_bfd.c b/isisd/isis_bfd.c
index 8fc7997d7..cf4b84179 100644
--- a/isisd/isis_bfd.c
+++ b/isisd/isis_bfd.c
@@ -118,7 +118,8 @@ static void bfd_adj_event(struct isis_adjacency *adj, struct prefix *dst,
 
 	int old_status = adj->bfd_session->status;
 
-	adj->bfd_session->status = new_status;
+	BFD_SET_CLIENT_STATUS(adj->bfd_session->status, new_status);
+
 	if (old_status == new_status)
 		return;
 
diff --git a/lib/bfd.c b/lib/bfd.c
index 00dbd1b3d..ffb3cbc1f 100644
--- a/lib/bfd.c
+++ b/lib/bfd.c
@@ -315,6 +315,8 @@ const char *bfd_get_status_str(int status)
 		return "Down";
 	case BFD_STATUS_UP:
 		return "Up";
+	case BFD_STATUS_ADMIN_DOWN:
+		return "Admin Down";
 	case BFD_STATUS_UNKNOWN:
 	default:
 		return "Unknown";
diff --git a/lib/bfd.h b/lib/bfd.h
index e4781f4ea..7f5d11150 100644
--- a/lib/bfd.h
+++ b/lib/bfd.h
@@ -51,9 +51,17 @@ struct bfd_gbl {
 #define BFD_FLAG_BFD_CBIT_ON (1 << 3) /* Peer registered with CBIT set to on */
 #define BFD_FLAG_BFD_CHECK_CONTROLPLANE (1 << 4) /* BFD and controlplane daemon are linked */
 
-#define BFD_STATUS_UNKNOWN (1 << 0) /* BFD session status never received */
-#define BFD_STATUS_DOWN    (1 << 1) /* BFD session status is down */
-#define BFD_STATUS_UP      (1 << 2) /* BFD session status is up */
+#define BFD_STATUS_UNKNOWN    (1 << 0) /* BFD session status never received */
+#define BFD_STATUS_DOWN       (1 << 1) /* BFD session status is down */
+#define BFD_STATUS_UP         (1 << 2) /* BFD session status is up */
+#define BFD_STATUS_ADMIN_DOWN (1 << 3) /* BFD session is admin down */
+
+#define BFD_SET_CLIENT_STATUS(current_status, new_status)		  \
+	do {								  \
+		(current_status) =					  \
+			(((new_status) == BFD_STATUS_ADMIN_DOWN) ?	  \
+					  BFD_STATUS_DOWN : (new_status));\
+	} while (0)
 
 enum bfd_sess_type {
 	BFD_TYPE_NOT_CONFIGURED,
diff --git a/lib/command.h b/lib/command.h
index 137d3748a..f6fe9af1b 100644
--- a/lib/command.h
+++ b/lib/command.h
@@ -398,6 +398,7 @@ struct cmd_node {
 #define WATCHFRR_STR "watchfrr information\n"
 #define ZEBRA_STR "Zebra information\n"
 #define FILTER_LOG_STR "Filter Logs\n"
+#define BFD_STR "BFD information\n"
 
 #define CMD_VNI_RANGE "(1-16777215)"
 #define CONF_BACKUP_EXT ".sav"
diff --git a/ospf6d/ospf6_bfd.c b/ospf6d/ospf6_bfd.c
index f0500601b..4e7a0050a 100644
--- a/ospf6d/ospf6_bfd.c
+++ b/ospf6d/ospf6_bfd.c
@@ -236,7 +236,7 @@ static int ospf6_bfd_interface_dest_update(ZAPI_CALLBACK_ARGS)
 			continue;
 
 		old_status = bfd_info->status;
-		bfd_info->status = status;
+		BFD_SET_CLIENT_STATUS(bfd_info->status, status);
 		monotime(&tv);
 		bfd_info->last_update = tv.tv_sec;
 
diff --git a/ospfd/ospf_bfd.c b/ospfd/ospf_bfd.c
index 05ec4991e..b9e78f4cd 100644
--- a/ospfd/ospf_bfd.c
+++ b/ospfd/ospf_bfd.c
@@ -262,7 +262,7 @@ static int ospf_bfd_interface_dest_update(ZAPI_CALLBACK_ARGS)
 			continue;
 
 		old_status = bfd_info->status;
-		bfd_info->status = status;
+		BFD_SET_CLIENT_STATUS(bfd_info->status, status);
 		monotime(&tv);
 		bfd_info->last_update = tv.tv_sec;
 
diff --git a/pimd/pim_bfd.c b/pimd/pim_bfd.c
index 87d0f9fa2..01a798085 100644
--- a/pimd/pim_bfd.c
+++ b/pimd/pim_bfd.c
@@ -270,7 +270,7 @@ static int pim_bfd_interface_dest_update(ZAPI_CALLBACK_ARGS)
 			continue;
 		}
 		old_status = bfd_info->status;
-		bfd_info->status = status;
+		BFD_SET_CLIENT_STATUS(bfd_info->status, status);
 		monotime(&tv);
 		bfd_info->last_update = tv.tv_sec;
 
